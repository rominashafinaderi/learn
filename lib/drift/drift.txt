Drift یه کتابخونه هست که بهت کمک می‌کنه خیلی راحت‌تر با دیتابیس کار کنی. مثلا اگه یه برنامه داری که کاربرها رو ذخیره می‌کنه، Drift باعث می‌شه بتونی راحت‌تر اطلاعات رو ذخیره و بازیابی کنی.
drift ➝ مغز اصلی Drift که کمک می‌کنه دیتابیس داشته باشی.
drift_flutter ➝ چون داری از Flutter استفاده می‌کنی، اینو نیاز داری.
drift_dev و build_runner ➝ برای اینکه Drift بتونه کدهای لازم رو خودش بسازه.

/////Defining tables
All tables defined with Drift share a common structure to define columns:

Each table is defined as a Dart class that extends Table.
In table classes, columns are defined as late final fields.
The start of each field (like integer()) determines the type of the column.
Let's take another look at the table defined in the getting started example:


class TodoItems extends Table {
  IntColumn get id => integer().autoIncrement()();
  TextColumn get title => text()();
  DateTimeColumn get createdAt => dateTime().nullable()();
}
This defines two tables: todo_items with columns id, title, category, and created_at; and todo_category with columns id and description.

The SQL equivalent of this table would be:


CREATE TABLE todo_items (
  id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
  title TEXT,
  created_at INTEGER
);
////Column types

Dart Type	Drift Column	      SQL Type1
int	        late final age = integer()()   	INTEGER
BigInt      (as 64-bit, see why)	late final age = int64()()	INTEGER
String  	late final name = text()()	TEXT
bool	    late final isAdmin = boolean()()	INTEGER (1 or 0)
double	    late final height = real()()	REAL
Uint8List   late final image = blob()()	BLOB
DriftAny	late final value = sqliteAny()()	ANY (for STRICT tables)
DateTime    (see options)	late final createdAt = dateTime()()	INTEGERor TEXT
Your own    See type converter docs.	Depending on type
Enums	    intEnum or textEnum.	INTEGER or TEXT
Postgres Types    See postgres docs.	Depending on type

////cloumns type:

1️⃣ ستون‌های معمولی (بدون مقدار خالی - Required Columns)
یه ستون معمولی همیشه باید مقدار داشته باشه. مثلا، هر کاربر باید حتما یه اسم داشته باشه!

📌 مثال:
class Users extends Table {
  late final name = text()(); // هر کاربر باید اسم داشته باشه
}
✅ توی این جدول، هر ردیف حتما باید مقدار name داشته باشه

2️⃣ ستون‌های قابل‌خالی شدن (Nullable Columns)
بعضی وقت‌ها نمی‌خوایم یه مقدار حتماً پر بشه. مثلا، یه نفر ممکنه سن خودش رو ننویسه.

📌 مثال:
class Users extends Table {
  late final age = integer().nullable()(); // می‌تونه مقدار نداشته باشه (null)
}
✅ حالا این ستون می‌تونه مقدار نداشته باشه و خطا نمی‌ده.

3️⃣ مقدار پیش‌فرض (Default Values)
گاهی می‌خوایم یه مقدار پیش‌فرض داشته باشیم تا اگه کاربر چیزی وارد نکرد، اون مقدار خودکار تنظیم بشه.

🔹 روش ۱: مقدار پیش‌فرض توی پایگاه داده (با withDefault())
مثلاً، هر ردیف جدید یه "تاریخ ساخت" داشته باشه که خودکار مقدارش تنظیم بشه.

📌 مثال:
class Users extends Table {
  late final createdAt = dateTime().withDefault(currentDateAndTime)();
}
✅ حالا هر کاربری که ثبت بشه، createdAt خودکار مقدار می‌گیره!

4️⃣ ارتباط بین جداول (Foreign Key - کلید خارجی)
بعضی وقت‌ها یه جدول باید به جدول دیگه‌ای وصل بشه!
مثلاً، هر آلبوم باید مشخص کنه که کدوم خواننده (هنرمند) این آلبوم رو ساخته.

📌 مثال:

class Artists extends Table {
  late final id = integer().autoIncrement()(); // کلید اصلی خواننده
  late final name = text()(); // نام خواننده
}

class Albums extends Table {
  late final id = integer().autoIncrement()(); // کلید اصلی آلبوم
  late final name = text()(); // نام آلبوم
  late final artist = integer().references(Artists, #id)(); // این آلبوم متعلق به کدوم خواننده است؟
}
✅ حالا هر آلبوم به یک خواننده وصل می‌شه و مشخصه که کی اون رو ساخته.

🎯 خلاصه‌ی بحث:
🔹 ستون‌های معمولی مقدارشون همیشه باید پر باشه.
🔹 ستون‌های nullable() می‌تونن مقدار نداشته باشن.
🔹 withDefault() مقدار پیش‌فرضی توی پایگاه داده تنظیم می‌کنه.
🔹 clientDefault() مقدار پیش‌فرض رو توی Dart مشخص می‌کنه (بدون نیاز به تغییر پایگاه داده).
🔹 references() باعث می‌شه یه جدول به جدول دیگه‌ای وصل بشه.

//////Additional validation checks
1️⃣ بررسی مقدار عددی (مثلاً سن نباید منفی باشه!)
اگه کسی سن خودش رو -۵ سال بزنه، این غیرممکنه!
پس می‌تونیم محدود کنیم که عدد سن باید ۰ یا بیشتر باشه.

📌 مثال:
late final Column<int> age = integer().check(age.isBiggerOrEqualValue(0))();
✅ حالا اگه کسی بخواد سنش رو عدد منفی بذاره، برنامه خطا می‌ده!
2️⃣ بررسی طول متن (مثلاً اسم نباید خالی باشه و خیلی هم طولانی نباشه!)
فرض کن توی یه فرم اسم می‌نویسی.
🔹 نباید اسم خالی باشه
🔹 نباید بیشتر از ۵۰ حرف باشه

📌 مثال:
late final name = text().withLength(min: 1, max: 50)();
✅ حالا دیگه اسم‌های خالی یا بیشتر از ۵۰ حرف، اجازه ثبت ندارن!

3️⃣ ستون‌هایی که خودشون مقدار حساب می‌کنن! (Generated Columns)
فرض کن یه مستطیل داری و می‌خوای مساحتش رو حساب کنی.
به جای اینکه هر بار دستی این کار رو انجام بدی، می‌تونی کاری کنی که خود پایگاه داده این محاسبه رو انجام بده!

📌 مثال:
class Squares extends Table {
  late final length = integer()(); // طول مستطیل
  late final width = integer()();  // عرض مستطیل
  late final area = integer().generatedAs(length * width)(); // مساحت = طول × عرض
}
✅ حالا هر وقت مقدار length یا width عوض بشه، مقدار area هم خودکار حساب می‌شه!


////Unique columns

تصور کن یه لیست از شماره تلفن دوستات نوشتی.
🔹 اگه دو تا از دوستات شماره یکسانی داشته باشن، قاطی می‌کنی، درسته؟
🔹 توی پایگاه داده هم بعضی ستون‌ها باید مقدار یکتا داشته باشن تا از این مشکلات جلوگیری بشه.

حالا بیا ببینیم چطور این کارو توی کد انجام بدیم!
لوگیری از مقدار تکراری در یک ستون (unique())
🔹 مثلاً نام کاربری توی یه سایت باید یکتا باشه.
🔹 نمی‌تونیم اجازه بدیم که دو نفر یه نام کاربری یکسان داشته باشن!

📌 چطور این کارو کنیم؟

late final username = text().unique()();
✅ حالا اگه یه نام کاربری تکراری باشه، پایگاه داده خطا می‌ده و ثبت نمی‌کنه!

2️⃣ جلوگیری از مقدار تکراری در ترکیب چند ستون (uniqueKeys)
🔹 مثلاً اگه بخوایم یه سیستم رزرو اتاق داشته باشیم، باید مطمئن شیم که یه اتاق خاص، توی یه روز خاص فقط یک بار رزرو بشه.
🔹 پس ترکیب ستون‌های اتاق (room) و تاریخ (onDay) باید منحصر‌به‌فرد باشه!

📌 چطور این کارو کنیم؟
class Reservations extends Table {
  late final reservationId = integer().autoIncrement()();
  late final room = text()();
  late final onDay = dateTime()();

  @override
  List<Set<Column>> get uniqueKeys => [
        {room, onDay} // هر اتاق فقط یک بار در روز خاص رزرو بشه
      ];
}
✅ حالا اگه کسی بخواد یه اتاقو توی یه روز خاص دوبار رزرو کنه، خطا می‌گیره!

3️⃣ سرعت دادن به جستجوها با ایندکس‌ها (@TableIndex)
🔹 فرض کن یه لیست خیلی بزرگ از شماره تلفن‌ها داری و دنبال یه شماره خاصی هستی.
🔹 اگه لیست مرتب نشده باشه، باید از اول تا آخر بگردی!
🔹 ولی اگه یه فهرست (ایندکس) از شماره‌ها داشته باشی، سریع‌تر می‌تونی پیداش کنی.

📌 مثلاً اگه توی یه جدول کاربران، زیاد دنبال name بگردیم، بهتره براش ایندکس بذاریم تا سریع‌تر پیدا بشه:

@TableIndex(name: 'user_name', columns: {#name})
class Users extends Table {
  late final id = integer().autoIncrement()();
  late final name = text()();
}
✅ حالا هر وقت توی Users دنبال اسم بگردیم، پایگاه داده سریع‌تر نتیجه رو پیدا می‌کنه!
4️⃣ ساخت ایندکس با دستور SQL (@TableIndex.sql)
🔹 اگه بخوایم یه ایندکس فقط برای یک سری داده خاص ایجاد کنیم، می‌تونیم از SQL استفاده کنیم.
🔹 مثلاً می‌خوایم فقط سفارش‌هایی که وضعیتشون pending (در انتظار پردازش) هست، ایندکس بشن.

📌 چطور این کارو کنیم؟
@TableIndex.sql('''
  CREATE INDEX pending_orders ON orders (creation_time)
    WHERE status == 'pending';
''')
class Orders extends Table {
  late final id = integer().autoIncrement()();
  late final totalAmount = integer()();
  late final creationTime = dateTime()();
  late final status = text()();
}
✅ حالا جستجو توی سفارش‌هایی که هنوز پردازش نشدن (pending) خیلی سریع‌تر انجام می‌شه!

🎯 خلاصه‌ی بحث:
✅ unique() → یه ستون خاص نباید مقدار تکراری داشته باشه (مثلاً نام کاربری)
✅ uniqueKeys → ترکیب چند ستون نباید تکراری باشه (مثلاً اتاق و روز رزرو)
✅ @TableIndex → جستجوها رو سریع‌تر می‌کنه (مثلاً پیدا کردن کاربرها بر اساس اسم)
✅ @TableIndex.sql → ایندکس‌های خاص برای بهینه‌سازی بیشتر (مثلاً فقط روی سفارش‌های pending)

////Custom constraints

1️⃣ اضافه کردن قوانین خاص برای ستون‌ها (customConstraint)
🔹 توی پایگاه داده هم می‌تونیم بگیم که یه ستون باید یه قانون خاصی رو رعایت کنه!

📌 مثلاً بگیم ستون name با حساسیت روی حروف بزرگ و کوچک ذخیره بشه:

late final name = text().nullable().customConstraint('COLLATE BINARY')();
✅ این یعنی "ali" و "Ali" رو به عنوان دو مقدار متفاوت بشناسه


2️⃣ اگه NOT NULL رو یادت بره، مشکل پیش میاد!
🔹 وقتی customConstraint اضافه می‌کنی، Drift بقیه تنظیمات رو حذف می‌کنه!
🔹 پس اگه می‌خوای NOT NULL هم بمونه، باید دستی اضافه‌ش کنی.

📌 مثلاً ستون username نباید مقدار خالی داشته باشه:

late final username = text().customConstraint('NOT NULL COLLATE BINARY')();
✅ حالا نمی‌تونی یه نام کاربری خالی وارد کنی!


3️⃣ اضافه کردن قوانین خاص برای کل جدول (customConstraints)
🔹 تصور کن یه قانون بذاری که می‌گه دو نفر نمی‌تونن همزمان عضو یه گروه خاص باشن.
🔹 توی پایگاه داده، می‌تونیم برای ترکیب چند ستون یه قانون خاص بذاریم!

📌 مثلاً برای این که ترکیب foo و bar به یه جدول دیگه اشاره کنه:

class TableWithCustomConstraints extends Table {
  late final foo = integer()();
  late final bar = integer()();

  @override
  List<String> get customConstraints => [
        'FOREIGN KEY (foo, bar) REFERENCES group_memberships ("group", user)',
      ];
}
✅ حالا این دو ستون با اطلاعات جدول دیگه هماهنگ می‌شن!

4️⃣ ذخیره‌ی داده‌ها با قوانین سخت‌گیرانه (isStrict)
🔹 تصور کن معلمت بگه که فقط باید از مداد مشکی برای نوشتن مشق استفاده کنی!
🔹 توی پایگاه داده هم می‌تونیم بگیم که فقط نوع‌های خاصی از داده‌ها مجاز باشن.

📌 مثلاً یه جدول رو سخت‌گیرانه تنظیم کنیم:

class Preferences extends Table {
  TextColumn get key => text()();
  AnyColumn get value => sqliteAny().nullable()();

  @override
  Set<Column<Object>>? get primaryKey => {key};

  @override
  bool get isStrict => true;
}
✅ حالا هر مقداری که ذخیره می‌کنی باید دقیقاً با نوع ستون بخونه!


5️⃣ تغییر نام ستون‌ها (named)
🔹 تصور کن اسم دوستت "محمد" باشه، ولی تو بهش "ممد" بگی.
🔹 توی پایگاه داده هم می‌تونیم اسم واقعی ستون رو یه چیز دیگه بذاریم.

📌 مثلاً ستون isAdmin رو به admin تغییر بدیم:

late final isAdmin = boolean().named('admin')();
✅ حالا اسم این ستون توی دیتابیس admin خواهد بود!

6️⃣ تغییر نام جدول‌ها (tableName)
🔹 اگه بخوایم اسم جدول رو توی پایگاه داده یه چیز خاص بذاریم:

class Products extends Table {
  @override
  String get tableName => 'product_table';
}
✅ جدول Products توی دیتابیس با اسم product_table شناخته می‌شه!


7️⃣ استفاده از int64() برای اعداد بزرگ
🔹 تو Dart، اعداد بزرگ توی جاوا اسکریپت ممکنه درست ذخیره نشن.
🔹 پس اگه عدد خیلی بزرگ ذخیره می‌کنی، بهتره از int64() استفاده کنی!

8️⃣ ذخیره‌ی تاریخ و زمان (DateTime) به شکل بهتر!
🔹 SQLite تاریخ رو به دو روش ذخیره می‌کنه:

عدد (تایم‌استمپ) → فقط تعداد ثانیه‌ها رو نگه می‌داره.
متن (ISO-8601) → دقیق‌تر و با اطلاعات منطقه زمانی!
📌 برای استفاده از روش بهتر (ISO-8601)، توی build.yaml این رو تنظیم کن:

targets:
  $default:
    builders:
      drift_dev:
        options:
          store_date_time_values_as_text: true
✅ حالا تاریخ‌ها رو دقیق‌تر و خواناتر ذخیره می‌کنه!

🎯 خلاصه‌ی بحث:
✅ customConstraint → اضافه کردن قوانین خاص برای یک ستون
✅ customConstraints → اضافه کردن قوانین خاص برای کل جدول
✅ isStrict → اجباری کردن رعایت نوع داده‌ها
✅ named → تغییر نام ستون‌ها در دیتابیس
✅ tableName → تغییر نام جدول در دیتابیس
✅ int64() → ذخیره‌ی اعداد خیلی بزرگ به شکل امن
✅ store_date_time_values_as_text → ذخیره‌ی تاریخ‌ها به شکل متن خوانا


///////////////////Generated row classes
1️⃣ دو مدل کلاس برای هر جدول!
وقتی یه جدول توی Drift می‌سازیم، دو تا کلاس خودکار تولید می‌شه:

✅ کلاس ردیف (Row Class) → مثل یه کارت شناسایی که تمام اطلاعات یه ردیف رو توی خودش داره.
✅ کلاس همراه (Companion Class) → مثل یه فرم ثبت‌نام که می‌تونی بعضی از اطلاعات رو وارد نکنی (مثلاً شماره دانش‌آموزی که خود مدرسه قراره بده).

2️⃣ مثال ساده: جدول کاربران
فرض کن یه جدول برای کاربران داریم:

class Users extends Table {
  late final id = integer().autoIncrement()(); // شناسه کاربر که خودکار اضافه می‌شه
  late final username = text()(); // نام کاربری
}
🔹 اینجا id خودکار مقدار می‌گیره، پس نباید موقع ثبت مقدار براش بدیم.

3️⃣ کلاس ردیف (User) → اطلاعات کامل هر ردیف
بعد از تعریف جدول، Drift یه کلاس به اسم User می‌سازه که هر ردیف رو نشون می‌ده:

class User {
  final int id; // شناسه کاربر (مثلاً: 1)
  final String username; // نام کاربری (مثلاً: "Ali")

  const User({required this.id, required this.username});

  @override
  int get hashCode => Object.hash(id, username);

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is User && other.id == this.id && other.username == this.username);
}
✅ این کلاس مثل یه کارت شناساییه که اطلاعات کامل یه کاربر رو داره!

4️⃣ کلاس همراه (UsersCompanion) → برای اضافه کردن یا ویرایش
حالا اگه بخوایم یه کاربر جدید ثبت کنیم، id رو نباید مقدار بدیم چون خود دیتابیس مقدارش رو مشخص می‌کنه. برای همین، Drift یه کلاس همراه (Companion) می‌سازه:

class UsersCompanion extends UpdateCompanion<User> {
  final Value<int> id; // مقدار `id` قابل تغییر نیست
  final Value<String> username; // مقدار `username` قابل تغییره

  const UsersCompanion({
    this.id = const Value.absent(), // `id` مقدار نمی‌گیره
    this.username = const Value.absent(), // `username` مقدار نمی‌گیره
  });

  UsersCompanion.insert({
    this.id = const Value.absent(), // `id` خود دیتابیس مقدار می‌ده
    required String username, // `username` رو باید وارد کنیم
  }) : username = Value(username);
}
✅ یعنی می‌تونیم کاربر جدید بسازیم بدون اینکه id رو بدیم

///

Migrations
Type converters
Code Generation
Platforms
Isolates
Testing
FAQ
Community
Table of contents
Example
Using row classes
Dataclass Name
Companions and Value
Updating with SQL expressions
Custom dataclass
Using records
Using another constructor
Custom companions
Static and asynchronous factories
Custom dataclass in drift files
JSON serialization
Key names
Generated row classes¶
For each table you define, drift generates two associated classes:

A row class: This class represents a full row of the table. Drift automatically returns instances of these classes for queries on tables, allowing you to access rows with type safety.
A companion class: While row classes represent a full row as it appears in the database, sometimes you also need a partial row (e.g. for updates or inserts which don't have values for auto-incrementing primary keys yet). For this, drift generates a companion class primarily used for inserts and updates.
Drift's row classes come with built-in equality, hashing, and basic serialization support. They also include a copyWith method for easy modification.

Example¶
A simple table to store usernames shows how the generated row and companion classes behave:


class Users extends Table {
  late final id = integer().autoIncrement()();
  late final username = text()();
}
For this table, drift generates a User class which roughly looks like this (with a few additional convenience methods now shown here):


// Simplified version of the row class generated by drift:
class User {
  final int id;
  final String username;

  const User({required this.id, required this.username});

  @override
  String toString() {
    // ...
  }

  @override
  int get hashCode => Object.hash(id, username);

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is User && other.id == this.id && other.username == this.username);
}
Note that User.id is a non-nullable field, reflecting that the column is also non-nullable in the database. When you're inserting a new User however, there's no value you could provide to id because the actual value is determined by the database. For this reason, drift also has companion classes to represent partial rows:


class UsersCompanion extends UpdateCompanion<User> {
  final Value<int> id;
  final Value<String> username;

  const UsersCompanion({
    this.id = const Value.absent(),
    this.username = const Value.absent(),
  });

  UsersCompanion.insert({
    this.id = const Value.absent(),
    required String username,
  }) : username = Value(username);

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    // ...
  }
}
In a companion, all fields are wrapped in a Value class that represents whether a column is present or not.

///////Using row classes
1️⃣ وقتی می‌خوای اطلاعات رو اضافه یا بخونی، چیکار باید بکنی؟
وقتی Drift دو کلاس ردیف (Row Class) و همراه (Companion Class) رو می‌سازه، می‌تونی باهاشون اضافه کنی، بخونی، یا تغییر بدی!

2️⃣ چطور یه ردیف جدید اضافه کنیم؟
✅ روش اول (مدیریت ساده)
اگه بخوایم یه کاربر جدید اضافه کنیم، می‌تونیم مستقیماً یه تابع ساده برای ثبت اطلاعات استفاده کنیم:

await db.managers.users.create((row) => row(username: 'firstuser'));
🔹 اینجا نیازی به Companion نداریم و فقط مقدار فیلدها رو می‌دیم.

✅ روش دوم (با Companion)

await db.users.insertOne(UsersCompanion(
  id: Value.absent(), // `id` خودکار مقدار می‌گیره
  username: Value('user'),
));
🔹 Value.absent() یعنی مقدار این ستون رو دستی نمی‌دیم.

3️⃣ چطور اطلاعات رو بخونیم؟
اگه بخوایم همه‌ی دسته‌بندی‌ها رو از دیتابیس بگیریم:

final List<Category> categories = await db.categories.all().get();
print('Current categories: $categories');
✅ اینجا کلاس Category خودکار ساخته شده و اطلاعات دسته‌بندی‌ها رو نشون می‌ده.

4️⃣ چطور اطلاعات رو آپدیت کنیم؟
✅ آپدیت کردن مقدار یه ردیف مشخص

await (db.update(db.users)..where((tbl) => tbl.id.equals(1)))
    .write(UsersCompanion(username: Value("Updated name")));
🔹 این کد نام کاربری کاربری که id=1 داره رو تغییر می‌ده.

✅ آپدیت با SQL Expression (مثلاً همه اسامی رو کوچیک کنیم)

await db
    .update(db.users)
    .write(UsersCompanion.custom(username: db.users.username.lower()));
🔹 lower() باعث می‌شه که همه نام‌های کاربری حروف کوچیک بشن

5️⃣ @DataClassName چیه و چه فایده‌ای داره؟
🚀 وقتی یه جدول تعریف می‌کنی، Drift اسم کلاس رو بر اساس اون انتخاب می‌کنه:
🔹 اگه اسم جدول "Users" باشه → کلاس User ساخته می‌شه
🔹 اگه اسم جدول "UserInfo" باشه → کلاس UserInfoData ساخته می‌شه

✅ اگه بخوای اسم خاصی انتخاب کنی، می‌تونی @DataClassName استفاده کنی:

@DataClassName('Category')
class Categories extends Table {
  late final id = integer().autoIncrement()();
  late final title = text()();
}
🔹 حالا به جای Categorie، کلاس Category ساخته می‌شه.

🎯 خلاصه‌ی بحث:
📌 اضافه کردن اطلاعات → می‌تونی از Companion استفاده کنی، ولی برای مدیریت ساده می‌تونی تابع create رو صدا بزنی.
📌 خواندن اطلاعات → db.categories.all().get() برای گرفتن همه داده‌های یه جدول.
📌 آپدیت کردن اطلاعات → write(UsersCompanion(...)) برای تغییر مقدار فیلدها.
📌 تغییر نام کلاس دیتابیس → @DataClassName('NewName') برای تغییر اسم کلاس.

///////////Custom dataclass

2️⃣ چطور کلاس سفارشی برای دیتابیس تعریف کنیم؟
✅ مثال: ایجاد یک کلاس User برای نمایش کاربران
🔹 اول، از @UseRowClass(User) برای مشخص کردن کلاس سفارشی استفاده می‌کنیم:

@UseRowClass(User)
class Users extends Table {
  IntColumn get id => integer().autoIncrement()();
  TextColumn get name => text()();
  DateTimeColumn get birthday => dateTime()();
}

// 🎯 کلاس سفارشی برای نمایش ردیف‌های دیتابیس
class User {
  final int id;
  final String name;
  final DateTime birthday;

  User({required this.id, required this.name, required this.birthday});
}
✅ حالا کلاس User مستقیماً نماینده‌ی داده‌های دیتابیسه!